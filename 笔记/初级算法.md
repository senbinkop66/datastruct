# 初级算法

##  数组

### 1. 删除排序数组中的重复项

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

```java
class Solution{
	public int removeDuplicates(int[] nums){
		int len=nums.length;
		if (len==0) return 0;
		if (len==1) return 1;
		int temp=nums[0];  //标志位
		int i=1;
		while (i<len){
			if (temp==nums[i]) {
				//因为是有序，所以相同就向前移动一位覆盖相同的一个
				for (int j=i; j<len-1; j++) {
					nums[j]=nums[j+1];
				}
				len--;  //长度减一
			}else{
				//不是重复的则把标志位后移
				temp=nums[i];
				i++;
			}
			
		}
		return len;
	}
}

public class TestArray1{
	
	public static void main(String[] args) {
		int[] testnums={0,0,1,1,1,2,2,3,3,4};
		Solution mysolution=new Solution();
		int newlen=mysolution.removeDuplicates(testnums);
		System.out.println(newlen);
		for (int i=0; i<newlen; i++) {
			if (i==newlen-1) {
				System.out.println(testnums[i]);
			}else{
				System.out.print(testnums[i]+" ,");
			}
		}
	}
}
```

待解决：实现的时间复杂度有点高，应该还可以减少移动次数，比如处理连续重复的情况.

### 2. 买卖股票的最佳时机 II

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票

```java
class Solution{
	public int maxProfit(int[] prices){
		int len=prices.length;
		if (len<=1) return 0;
		/* 分析可知需要小买大出收益最大，比较相邻的数值，以及连续增长的时候*/
		int sum=0;  //最大收益
		int flag=prices[0];  //标志位
		int i=1;
		while (i<len){
			if (flag>=prices[i]) {
				//当前比后一个比较的大时，属于亏损，,等于时没有意义。不交易
			}else{
				sum+=prices[i]-flag;  //后一个比前一个值大说明盈利，交易
			}
			flag=prices[i];  //设置标志位为当前值
			i++;
		}
		return sum;
	}
}

public class TestArray1{
	public static void main(String[] args) {
		int[] testprices={7,6,4,3,1};
		Solution mysolution=new Solution();
		int myMaxProfit=mysolution.maxProfit(testprices);
		System.out.println(myMaxProfit);
	}
}
```

可以不设置标志位减少内存消耗，可以直接比较,以及连续增加时的计算

使用动态规划解决

使用贪心算法解决

### 3. 旋转数组

给你一个数组，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**进阶：**

- 尽可能想出更多的解决方案，至少有 **三种** 不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 `O(1)` 的 **原地** 算法解决这个问题吗？

暴力移动 (k%len)*len 次，测试会超时,此方法消耗过大

```java
public void rotate(int[] nums,int k){
		int len=nums.length;
		if (len<=1 || k==0 || k%len==0) return;
		
		//计算k与len的关系,分析可知不管为多少都是移动k%len次
		k=k%len;  //此后len一定比k大

		int flag=nums[len-1];  //最后一个元素
		for (int i=0;i<k;i++){
			for (int j=len-1; j>0; j--) {
				nums[j]=nums[j-1];
			}
			nums[0]=flag;
			flag=nums[len-1];
		}
	}
```

使用临时数组    借助辅助空间大小为k的数组

```java
class Solution{
	public void rotate(int[] nums,int k){
		int len=nums.length;
		if (len<=1 || k==0 || k%len==0) return;
		
		//计算k与len的关系,分析可知不管为多少都是移动k%len次
		k=k%len;  //此后len一定比k大
		
		int[] numsK=new int[k];  //辅助空间,用于保存后k个
		for (int i=0;i<k;i++) {
			numsK[i]=nums[len-1-i];
		}
		for (int i=len-1; i>=k; i--) {
			//前len-k个后移k位
			nums[i]=nums[i-k];
		}
		for (int i=k-1;i>=0;i--){
			//把保存的k个放在前面来
			nums[i]=numsK[k-1-i];
		}
	}
}
```

可以运行通过，但太耗内存，可以判断k与len-k的大小，然后辅助空间用于存储小的一个，虽然也耗内存

```java
import java.util.*;

class Solution{
	public void rotate(int[] nums,int k){
		int len=nums.length;
		if (len<=1 || k==0 || k%len==0) return;
		
		//计算k与len的关系,分析可知不管为多少都是移动k%len次
		k=k%len;  //此后len一定比k大
		
		int temp=nums[0];
		for (int i=0;i<k;i++) {
			//先把前k个与后k个换位置
			nums[i]=nums[len-k+i];
			nums[len-k+i]=temp;
			temp=nums[i+1];
		}
/*
		temp=nums[2*k-1];
		for (int i=0;i<len-k;i++) {
			nums[2*k-1+i]=nums[len-1-i];
			nums[len-1-i]=nums[len-1-i-k];
			nums[len-1-i-k]=temp;
			temp=nums[2*k+i];
		}
*/
	}
}

public class TestArray1{
	public static void main(String[] args) {
		int[] testnums={1,2,3,4,5,6,7,8,9,10};
		Solution mysolution=new Solution();
		int k=3;
		System.out.println(Arrays.toString(testnums));
		mysolution.rotate(testnums,k);
		System.out.println(Arrays.toString(testnums));
		int[] testnums2={1,2,3,4,5,6,7,8,9,10};
		k=7;
		mysolution.rotate(testnums2,k);
		System.out.println(Arrays.toString(testnums2));
	}
}
```

这个还存在问题

多次反转

环形旋转

### 4. 存在重复元素

给定一个整数数组，判断是否存在重复元素。如果存在一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

暴力解法超时

```java
public boolean containsDuplicate(int[] nums){
		int len=nums.length;
		if (len<=1) return false;
		//从小到大排序
		for (int i=0;i<len-1;i++) {
			for (int j=i+1;j<len;j++){
				if (nums[i]==nums[j]) {
					return true;
				}
			}
		}
		return false;
		
	}
```

使用set

```java
public boolean containsDuplicate(int[] nums){
		int len=nums.length;
		if (len<=1) return false;
		
		//使用set
		Set<Integer> set=new HashSet<>();
		for (int n:nums){
			//当重复添加返回true
			if (!set.add(n)) {
				return true;
			}
		}
		return false;
	}
```

先排序，然后比较



### 5.  只出现一次的数字

